# Java

[TOC]

## 1\. Java 中的面向对象编程 (OOP) 的基本概念是什么？

面向对象编程 (OOP) 的核心概念包括：

* **封装 (Encapsulation)**：将数据（属性）和操作数据的代码（方法）捆绑到一个单元（即类）中，并对外部隐藏对象的内部状态。这有助于保护数据不被意外修改。
* **抽象 (Abstraction)**：向用户隐藏复杂的实现细节，只暴露必要的功能。抽象类和接口是实现抽象的方式。
* **继承 (Inheritance)**：允许一个类（子类）获取另一个类（父类）的属性和方法。这促进了代码重用和创建类层次结构。
* **多态 (Polymorphism)**：允许不同类的对象对同一消息（方法调用）做出不同的响应。它可以通过方法重载（编译时多态）和方法重写（运行时多态）实现。

## 2\. `final`, `finally`, 和 `finalize` 关键字之间有什么区别？

* **`final`**：是一个关键字，可用于变量、方法和类。
  * `final` 变量：其值一旦被赋值后不能改变（常量）。
  * `final` 方法：不能在子类中被重写 (override)。
  * `final` 类：不能被继承。
* **`finally`**：是异常处理中 `try-catch` 语句块的一部分。无论是否发生异常，`finally` 块中的代码总会被执行。它通常用于释放资源。
* **`finalize`**：是 `Object` 类的一个方法，在对象被垃圾回收器回收之前调用。它的目的是执行清理操作，但不保证何时执行，通常不推荐依赖它进行资源释放。

## 3\. `String`, `StringBuffer`, 和 `StringBuilder` 类之间有什么主要区别？

* **`String`**：是不可变的 (immutable)。对 `String` 对象的任何修改都会创建一个新的 `String` 对象。
* **`StringBuffer`**：是可变的 (mutable)，并且其方法是同步的 (synchronized)，因此是线程安全的。适用于多线程环境中需要修改字符串的场景。
* **`StringBuilder`**：也是可变的 (mutable)，但其方法不是同步的，因此不是线程安全的。在单线程环境中，由于没有同步开销，通常比 `StringBuffer` 更高效。

## 4\. `ClassNotFoundException` 和 `NoClassDefFoundError` 有什么区别？

* **`ClassNotFoundException`**：是一个异常 (Exception)，表示在运行时类加载器试图加载类定义时，在类路径 (classpath) 中找不到该类的 `.class` 文件。这通常发生在尝试通过字符串名称动态加载类时（例如使用 `Class.forName()`）。
* **`NoClassDefFoundError`**：是一个错误 (Error)，表示 JVM 在编译时能够找到该类，但在运行时由于某种原因（例如，类文件在编译后被移除或损坏，或者在静态初始化块中发生异常）无法加载该类的定义。

## 5\. Java 中的检查型异常 (Checked Exception) 和非检查型异常 (Unchecked Exception) 有什么区别？

* **检查型异常 (Checked Exception)**：是在编译时被检查的异常。如果一个方法可能抛出检查型异常，那么它必须在方法签名中使用 `throws` 关键字声明该异常，或者在方法内部使用 `try-catch` 块捕获并处理它。例如 `IOException`, `SQLException`。
* **非检查型异常 (Unchecked Exception)**：通常是运行时异常 (`RuntimeException` 及其子类) 或错误 (`Error` 及其子类)。编译器不强制要求处理或声明非检查型异常。它们通常表示程序中的逻辑错误 (如 `NullPointerException`, `ArrayIndexOutOfBoundsException`) 或 JVM 无法恢复的严重问题 (如 `OutOfMemoryError`)。

## 6\. 描述一下 Java 中 `equals()` 和 `hashCode()` 方法之间的契约

`equals()` 和 `hashCode()` 方法在 `Object` 类中定义，它们之间存在重要的契约，尤其是在将对象存储在基于哈希的集合（如 `HashMap`, `HashSet`）中时：

1. **如果两个对象通过 `equals()` 方法比较是相等的，那么它们的 `hashCode()` 方法必须返回相同的整数值**。
2. 如果两个对象通过 `equals()` 方法比较是不相等的，那么它们的 `hashCode()` 方法不要求返回不同的整数值。但是，为了提高哈希表的性能，应尽量使不相等的对象返回不同的哈希码。
3. `hashCode()` 方法在对象的生命周期内，只要 `equals()` 比较中使用的信息没有改变，多次调用就必须始终返回相同的整数值。
    违反这些契约可能导致基于哈希的集合行为不正确（例如，无法找到已存入的对象）。

## 7\. 抽象类 (Abstract Class) 和接口 (Interface) 在 Java 中有什么区别？

| 特性             | 抽象类 (Abstract Class)                                  | 接口 (Interface)                                                              |
| ---------------- | ---------------------------------------------------------- | --------------------------------------------------------------------------- |
| **方法实现** | 可以包含抽象方法（无实现）和具体方法（有实现）。                   | 在 Java 8 之前，所有方法都是抽象的（隐式）。Java 8+ 允许包含 `default` 和 `static` 方法（有实现）。 |
| **变量** | 可以包含实例变量（非 `static` 非 `final`）和类变量 (`static`)。 | 只能包含常量（隐式为 `public static final`）。                               |
| **构造函数** | 可以有构造函数，但不能被直接实例化；构造函数由子类调用。                   | 不能有构造函数，不能被实例化。                                              |
| **继承** | 一个类只能继承一个抽象类（单继承）。                               | 一个类可以实现多个接口（多重实现）。                                        |
| **访问修饰符** | 成员可以是 `public`, `protected`, `private` (抽象方法不能是 `private`) 或默认。 | 成员隐式为 `public`。                                                        |
| **目的** | 表示 "is-a" 关系，定义对象的共同本质或特性。                     | 定义 "can-do" 行为，即对象应具备的功能或契约。                                   |

## 8\. Java 中的静态方法和实例方法有什么区别？

* **实例方法 (Instance Methods)**：
  * 属于类的特定实例（对象）。
  * 必须通过对象引用来调用。
  * 可以直接访问类的实例变量和实例方法，也可以访问静态变量和静态方法。
  * `this` 关键字在实例方法中指向调用该方法的当前对象。
* **静态方法 (Static Methods)**：
  * 属于类本身，而不是类的任何特定实例。
  * 可以直接通过类名调用，无需创建对象。
  * 只能直接访问类的静态变量和调用其他静态方法。不能直接访问实例变量或实例方法（除非通过对象引用）。
  * 静态方法中不能使用 `this` 关键字，因为它不与任何特定实例相关联。

## 9\. 解释 Java 中的垃圾回收 (Garbage Collection) 机制

Java 中的垃圾回收 (GC) 是一种自动内存管理过程，用于识别和丢弃应用程序不再需要的对象，以便回收和重用内存。

* **目的**：防止内存泄漏，并减轻开发者手动管理内存分配和释放的负担。
* **工作原理**：当一个对象不再被任何活动部分引用（即变得“不可达”）时，它就有资格被垃圾回收。JVM 的垃圾回收器会定期或在内存不足时运行，查找这些不可达对象并释放它们占用的内存。
* **触发**：开发者可以通过调用 `System.gc()` 或 `Runtime.gc()` 来建议 JVM 进行垃圾回收，但不能保证立即执行。
* **`finalize()` 方法**：在对象被回收前，垃圾回收器可能会调用该对象的 `finalize()` 方法，用于执行一些清理操作。但不推荐依赖此方法进行关键资源释放。
    Java 堆内存通常分为不同的代（如新生代、老年代），使用不同的 GC 算法来提高效率。

## 10\. `HashMap` 在 Java 中是如何工作的？它与 `Hashtable` 有何不同？

**`HashMap` 工作原理**：
`HashMap` 存储键值对 (key-value pairs)。它内部使用一个数组（称为哈希桶或桶数组），并通过键的 `hashCode()` 方法计算出的哈希值来确定键值对在数组中的存储位置（索引）。

* **`put(key, value)`**：计算 `key` 的哈希码，找到对应的桶。如果该桶为空，则直接存入。如果发生哈希冲突（多个键映射到同一个桶），键值对会以链表或红黑树（从 Java 8 开始，当链表长度超过一定阈值时）的形式存储在该桶中。如果键已存在，则更新其值。
* **`get(key)`**：计算 `key` 的哈希码找到对应的桶，然后在桶内（链表或树）通过 `equals()` 方法比较键来查找确切的值。
    为了高效运作，`HashMap` 依赖于 `hashCode()` 和 `equals()` 方法的正确实现。

**`HashMap` vs `Hashtable`**：

| 特性           | `HashMap`                                      | `Hashtable`                                       |
| -------------- | ---------------------------------------------- | ------------------------------------------------- |
| **同步性** | 非同步 (non-synchronized)，不是线程安全的。 | 同步 (synchronized)，线程安全的。             |
| **Null 值** | 允许一个 `null` 键和多个 `null` 值。        | 不允许 `null` 键或 `null` 值。                |
| **迭代器** | 提供 `Iterator` (fail-fast)。          | 提供 `Enumerator` (非 fail-fast) 和 `Iterator`。 |
| **性能** | 通常比 `Hashtable` 快，因为它不是同步的。 | 由于同步开销，通常较慢。                       |
| **继承** | 继承自 `AbstractMap`。                        | 继承自 `Dictionary` (一个遗留类)。            |
| **推荐使用** | 在非并发环境中是首选。可使用 `Collections.synchronizedMap()` 或 `ConcurrentHashMap` 实现线程安全。 | 通常被认为是遗留类，不推荐在新代码中使用。       |

## 11\. `ArrayList` 和 `LinkedList` 之间有哪些主要区别？何时应优先选择使用哪个？

`ArrayList` 和 `LinkedList` 都实现了 `List` 接口，但它们的内部数据结构和性能特征不同。

| 特性             | `ArrayList`                                                                 | `LinkedList`                                                                                                 |
| ---------------- | --------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------ |
| **内部结构** | 基于动态数组 (resizable array) 实现。                         | 基于双向链表 (doubly linked list) 实现。每个节点存储数据以及指向前一个和后一个节点的引用。 |
| **随机访问 (`get(index)`)** | 性能为 O(1)，因为可以直接通过索引访问数组元素。                    | 性能为 O(n)，需要从头或尾开始遍历链表来到达指定索引的元素。                               |
| **插入/删除元素** | 在列表末尾添加通常是 O(1) (摊销，不考虑扩容)。在列表中间插入或删除是 O(n)，因为需要移动后续元素。 | 在列表的开头或末尾插入/删除是 O(1)。在列表中间操作，如果已知节点引用则为 O(1)，否则查找节点需要 O(n)。 |
| **内存开销** | 内存开销相对较小。                                                              | 每个节点都需要额外的空间来存储指向前后节点的引用，因此内存开销通常比 `ArrayList` 大。                    |

**选择时机**：

* 优先选择 **`ArrayList`**：当主要操作是随机访问元素（通过索引获取）且插入/删除操作较少或主要在列表末尾时。它是更常用的 `List` 实现。
* 优先选择 **`LinkedList`**：当主要操作是在列表的开头、末尾或中间频繁地插入和删除元素时，并且随机访问不是主要需求。它也适用于实现队列和栈。

## 12\. Java 中 `wait()` 和 `sleep()` 方法有什么区别？

`wait()` 和 `sleep()` 都是用于暂停线程执行的方法，但它们在行为和用途上有显著区别：

| 特性             | `wait()`                                                                | `sleep()`                                                          |
| ---------------- | ----------------------------------------------------------------------- | ------------------------------------------------------------------ |
| **所属类** | 是 `java.lang.Object` 类的方法。                                   | 是 `java.lang.Thread` 类的静态方法。                         |
| **锁的释放** | 当线程调用对象的 `wait()` 方法时，它会释放该对象上的锁（监视器锁）。     | 当线程调用 `Thread.sleep()` 时，它不会释放任何它可能持有的锁。 |
| **唤醒条件** | 线程会一直等待，直到另一个线程调用相同对象上的 `notify()` 或 `notifyAll()` 方法，或者等待超时（如果调用了带超时的 `wait()` 版本），或者线程被中断。 | 线程会在指定的毫秒数后自动唤醒，或者如果它被中断。            |
| **调用上下文** | 必须在同步代码块或同步方法中调用（即当前线程必须持有对象的锁）。          | 可以在任何地方调用。                                        |
| **用途** | 主要用于线程间的协作和同步，例如实现生产者-消费者模式。              | 主要用于暂停当前线程的执行一段指定时间，例如用于轮询或控制执行速率。 |

## 13\. 描述 Java 内存模型中的堆 (Heap) 和栈 (Stack) 内存

Java 虚拟机 (JVM) 将内存划分为几个不同的区域，其中堆和栈是最重要的两个：

* **栈内存 (Stack Memory)**：
  * 每个线程都有自己的私有栈。
  * 栈用于存储方法调用的帧 (stack frames)。每个方法调用都会创建一个新的帧，该帧包含方法的局部变量、操作数栈和对其他帧的引用。
  * 局部变量（包括基本数据类型的值和对象的引用变量）存储在栈上。
  * 栈内存的分配和释放是自动管理的，通常遵循后进先出 (LIFO) 原则。当方法返回时，其对应的栈帧会被销毁。
  * 栈内存大小通常比堆内存小。
* **堆内存 (Heap Memory)**：
  * 堆是 JVM 中所有线程共享的内存区域。
  * 所有通过 `new` 关键字创建的对象实例和数组都存储在堆内存中。
  * 堆内存由垃圾回收器 (Garbage Collector) 自动管理。当对象不再被引用时，垃圾回收器会回收它们占用的内存。
  * 堆内存通常是 JVM 中最大的一块内存区域，其大小可以在 JVM 启动时配置。
  * 堆内存进一步划分为不同区域，如新生代（Eden, Survivor spaces）和老年代，以优化垃圾回收过程。

## 14\. `volatile` 关键字在 Java 中有什么作用？为什么要使用它？

`volatile` 是一个字段修饰符，用于确保共享变量的更改在多线程环境中的可见性，并防止指令重排序的某些情况。
**作用与原因**：

1. **可见性 (Visibility)**：当一个线程修改了一个 `volatile` 变量的值，这个新值会立即被写入主内存，并且其他线程在读取该变量时会从主内存中获取最新的值，而不是使用其本地 CPU 缓存中的旧值。这确保了所有线程都能看到对 `volatile` 变量的最新修改。
2. **防止指令重排序 (Instruction Reordering)**：`volatile` 关键字会插入内存屏障，这可以防止编译器和处理器对 `volatile` 变量相关的读写操作进行某些类型的重排序，从而保证了特定操作的有序性。
3. **原子性 (Atomicity)**：`volatile` 本身不保证复合操作的原子性（例如 `i++`，它涉及读、改、写三个步骤）。它仅保证对单个 `volatile` 变量的读或写操作是原子的（对于 `long` 和 `double` 类型的变量，从 Java 5 开始，`volatile` 读写也是原子的）。

**使用场景**：

* 通常用于状态标志（如一个线程修改一个布尔标志来通知另一个线程停止）。
* 在实现某些并发模式（如双重检查锁定，DCL）时，确保实例的正确发布。
    `volatile` 通常被认为是比锁更轻量级的同步机制，但其适用场景有限。当变量的更新不依赖于其当前值，或者变量的写操作由单个线程控制时，`volatile` 可能是一个合适的选择。

## 15\. 什么是 `ThreadLocal` 类？如何以及为何使用它？

`ThreadLocal` 类用于创建线程局部变量。这意味着每个线程都可以通过 `ThreadLocal` 实例访问其自己独立的、初始化的变量副本，而不会与其他线程的副本发生冲突或干扰。
**如何使用**：

1. 创建一个 `ThreadLocal` 实例，通常作为类的 `private static` 字段。
2. 可以重写其 `initialValue()` 方法来为每个线程提供初始值（或者在首次调用 `get()` 且未调用 `set()` 时提供）。
3. 在线程内部，使用 `get()` 方法获取当前线程的变量副本，使用 `set()` 方法设置当前线程的变量副本。
4. 使用完毕后，可以通过 `remove()` 方法清理当前线程的变量副本，以防止内存泄漏，尤其是在使用线程池的情况下。

**为何使用**：

* **线程安全**：允许每个线程拥有自己的变量实例，从而避免了在多线程环境下对共享状态进行同步的复杂性。
* **状态隔离**：用于在每个线程中维护一些与该线程相关的状态，例如用户 ID、事务 ID、数据库连接等，而不需要显式地在方法间传递这些状态。
* **性能**：在某些情况下，通过避免使用重量级锁来实现线程安全，`ThreadLocal` 可以提高性能。

例如，`ThreadLocal` 可以用来为每个线程维护一个独立的日期格式化器（因为 `SimpleDateFormat` 不是线程安全的）。

## 16\. 什么是类型擦除 (Type Erasure)？它在 Java 泛型中如何工作？

类型擦除是 Java 编译器处理泛型的一种机制。在编译期间，编译器会检查泛型的类型约束，以确保类型安全。之后，它会“擦除”泛型类型信息，将泛型类型替换为其上界（bounded type）或 `Object`（如果没有显式上界）。
**工作方式**：

1. **替换类型参数**：所有类型参数都被替换为它们的边界；如果没有指定边界（如 `List<T>`），则替换为 `Object`。如果指定了边界（如 `List<T extends Number>`），则替换为该边界类型 (`Number`)。
2. **插入类型转换**：如果需要，编译器会在适当的位置插入类型转换（cast），以保持类型安全。例如，从泛型集合中获取元素时，会将其转换为预期的类型。
3. **生成桥方法 (Bridge Methods)**：在某些情况下（如泛型类继承或实现泛型接口时），编译器会生成桥方法以保持多态性并与旧的非泛型代码兼容。

**影响**：

* **运行时无泛型信息**：由于类型擦除，泛型类型信息在运行时是不可用的。你不能在运行时执行如 `if (obj instanceof List<String>)` 这样的检查。
* **兼容性**：类型擦除的主要目的是为了向后兼容，允许泛型代码与 Java 5 之前的非泛型代码一起工作。
* **限制**：导致了一些泛型的限制，例如不能创建泛型类型的数组 (`new T[]` 是非法的)，不能实例化类型参数 (`new T()`)，以及静态上下文中不能引用类型参数。

## 17\. Java 中的 fail-fast 和 fail-safe 迭代器有什么区别？请举例说明

**Fail-fast 迭代器**：

* 在创建迭代器后，如果集合的结构被修改（例如添加、删除元素），而不是通过迭代器自身的 `remove()` 方法进行修改，那么迭代器会立即抛出 `ConcurrentModificationException`。
* 它们直接在原始集合上操作。
* 这种机制旨在尽快检测到并发修改问题，防止不确定的行为。
* **示例**：`ArrayList`, `HashMap`, `HashSet` 的迭代器都是 fail-fast 的。

**Fail-safe 迭代器** (也称为 non-fail-fast)：

* 在迭代时，它们工作在原始集合的一个克隆或快照上，或者使用某种机制来容忍并发修改而不抛出异常。
* 因此，它们不会因为集合在迭代期间被其他线程修改而抛出 `ConcurrentModificationException`。
* 缺点是迭代器可能不会反映迭代开始后对集合所做的修改。
* **示例**：`CopyOnWriteArrayList`, `ConcurrentHashMap` 的迭代器是 fail-safe 的。

## 18\. Java 是按值传递 (pass-by-value) 还是按引用传递 (pass-by-reference)？

Java **始终是按值传递 (pass-by-value)**。
这意味着当一个参数被传递给一个方法时，传递的是该参数值的副本。

* **对于基本数据类型 (primitive types)**：传递的是实际值的副本。方法内部对参数副本的修改不会影响到原始变量。
* **对于对象引用 (object references)**：传递的是对象引用的副本。原始引用和参数引用都指向堆中的同一个对象。因此，如果方法通过这个引用副本修改了对象的内部状态（例如，调用对象的setter方法或修改其字段），这些更改会反映在原始对象上，因为它们指向同一个对象。但是，如果方法将参数引用重新指向一个新的对象，这不会影响原始引用变量。

简单来说，Java 传递的是变量所持有内容的副本。对于基本类型，内容是值本身；对于对象，内容是对象的引用（内存地址）。
